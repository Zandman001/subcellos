use std::collections::HashSet;

/// Sequencer step containing notes to trigger
#[derive(Clone, Debug)]
pub struct SequencerStep {
    pub notes: Vec<SequencerNote>,
}

#[derive(Clone, Debug)]
pub struct SequencerNote {
    pub midi: u8,
    pub vel: f32,
    pub legato: bool,
}

#[derive(Clone, Debug, Copy)]
pub enum SequencerResolution {
    Quarter,     // 1/4
    Eighth,      // 1/8
    Sixteenth,   // 1/16
    ThirtySecond,// 1/32
    EighthTriplet, // 1/8t
    SixteenthTriplet, // 1/16t
}

impl SequencerResolution {
    pub fn steps_per_beat(&self) -> f32 {
        match self {
            SequencerResolution::Quarter => 1.0,
            SequencerResolution::Eighth => 2.0,
            SequencerResolution::Sixteenth => 4.0,
            SequencerResolution::ThirtySecond => 8.0,
            SequencerResolution::EighthTriplet => 3.0,
            SequencerResolution::SixteenthTriplet => 6.0,
        }
    }
}

/// Events generated by the sequencer for the audio engine
#[derive(Debug, PartialEq)]
pub enum SequencerEvent {
    NoteOn { note: u8, vel: f32 },
    NoteOff { note: u8 },
}

/// Sample-accurate sequencer that runs in the audio thread
/// 
/// Uses f64 phase accumulation for drift-free timing. The phase represents
/// position within the pattern (0.0 to 1.0 = one full loop).
pub struct SequencerModule {
    // Pattern data
    steps: Vec<SequencerStep>,
    resolution: SequencerResolution,
    length: usize,
    
    // Playback state
    playing: bool,
    
    // Phase accumulator (0.0 to 1.0 = one complete loop through pattern)
    // Using f64 for precision to prevent drift over long playback
    phase: f64,
    
    // Phase increment per sample (calculated from BPM, resolution, length, sample_rate)
    phase_inc: f64,
    
    // For tempo mode: track the last transport phase to detect beat boundaries
    last_transport_phase: f32,
    
    // Current step index (derived from phase)
    current_step: usize,
    prev_step: isize,
    
    // Note tracking
    held_notes: HashSet<u8>,
    
    // Timing
    sample_rate: f64,
    bpm: f64,
    
    // Mode
    mode: SequencerMode,
    local_bpm: f64,
}

#[derive(Clone, Debug, Copy, PartialEq)]
pub enum SequencerMode {
    Tempo, // Follow global transport
    Poly,  // Use local BPM
}

impl SequencerModule {
    pub fn new(sample_rate: f32) -> Self {
        let mut seq = Self {
            steps: Vec::new(),
            resolution: SequencerResolution::Sixteenth,
            length: 16,
            playing: false,
            phase: 0.0,
            phase_inc: 0.0,
            last_transport_phase: 0.0,
            current_step: 0,
            prev_step: -1,
            held_notes: HashSet::new(),
            sample_rate: sample_rate as f64,
            bpm: 120.0,
            mode: SequencerMode::Tempo,
            local_bpm: 120.0,
        };
        seq.update_phase_inc();
        seq
    }
    
    /// Set the pattern - called from UI thread, processed in audio callback
    pub fn set_pattern(&mut self, steps: Vec<SequencerStep>, resolution: SequencerResolution, length: usize) {
        self.steps = steps;
        self.resolution = resolution;
        self.length = length.max(1);
        self.update_phase_inc();
    }
    
    /// Set global BPM (for tempo mode)
    pub fn set_bpm(&mut self, bpm: f32) {
        self.bpm = (bpm as f64).clamp(20.0, 300.0);
        if self.mode == SequencerMode::Tempo {
            self.update_phase_inc();
        }
    }
    
    /// Set local BPM (for poly mode)
    pub fn set_local_bpm(&mut self, bpm: f32) {
        self.local_bpm = (bpm as f64).clamp(20.0, 300.0);
        if self.mode == SequencerMode::Poly {
            self.update_phase_inc();
        }
    }
    
    /// Set mode and update timing accordingly
    pub fn set_mode(&mut self, mode: SequencerMode) {
        self.mode = mode;
        self.update_phase_inc();
    }
    
    /// Calculate phase increment per sample
    /// 
    /// phase goes 0.0 -> 1.0 over one complete pattern loop
    /// phase_inc = (steps_per_second) / (length * sample_rate)
    ///           = (bpm/60 * steps_per_beat) / (length * sample_rate)
    fn update_phase_inc(&mut self) {
        let effective_bpm = match self.mode {
            SequencerMode::Tempo => self.bpm,
            SequencerMode::Poly => self.local_bpm,
        };
        
        let steps_per_beat = self.resolution.steps_per_beat() as f64;
        let beats_per_second = effective_bpm / 60.0;
        let steps_per_second = beats_per_second * steps_per_beat;
        
        // phase goes 0->1 over `length` steps
        // so phase_inc = steps_per_second / length / sample_rate
        self.phase_inc = steps_per_second / (self.length as f64) / self.sample_rate;
    }
    
    /// Start playback from beginning
    pub fn start(&mut self) {
        self.playing = true;
        self.phase = 0.0;
        self.current_step = 0;
        self.prev_step = -1;
        self.last_transport_phase = 0.0;
    }
    
    /// Stop playback and release all held notes
    pub fn stop(&mut self) -> Vec<SequencerEvent> {
        self.playing = false;
        
        // Release all held notes
        let mut events = Vec::new();
        for note in &self.held_notes {
            events.push(SequencerEvent::NoteOff { note: *note });
        }
        self.held_notes.clear();
        
        events
    }
    
    /// Process one sample and generate events
    /// 
    /// `transport_phase`: Global transport phase (0.0-1.0 per beat), used in Tempo mode
    ///                    to stay synced with the global clock.
    /// 
    /// Returns: (events, playhead_position_normalized)
    pub fn process(&mut self, transport_phase: f32) -> (Vec<SequencerEvent>, f32) {
        if !self.playing || self.steps.is_empty() {
            return (Vec::new(), 0.0);
        }
        
        // Advance phase based on mode
        match self.mode {
            SequencerMode::Tempo => {
                // In tempo mode, we use the global transport to stay in sync.
                // We advance our own phase accumulator but use the transport's
                // beat boundaries to correct for any drift.
                
                // Detect beat boundary (transport wrapped from high to low)
                let beat_wrapped = transport_phase < self.last_transport_phase - 0.5;
                self.last_transport_phase = transport_phase;
                
                // Advance phase
                self.phase += self.phase_inc;
                
                // On beat boundary, snap to beat-aligned position to prevent drift
                if beat_wrapped {
                    // Calculate how many beats per loop
                    let steps_per_beat = self.resolution.steps_per_beat() as f64;
                    let beats_per_loop = self.length as f64 / steps_per_beat;
                    
                    // Current beat within loop (fractional)
                    let current_beat_in_loop = self.phase * beats_per_loop;
                    
                    // Snap to nearest beat boundary
                    let snapped_beat = current_beat_in_loop.round();
                    self.phase = snapped_beat / beats_per_loop;
                }
                
                // Wrap phase
                if self.phase >= 1.0 {
                    self.phase -= self.phase.floor();
                }
            }
            SequencerMode::Poly => {
                // In poly mode, we're fully independent - just advance our phase
                self.phase += self.phase_inc;
                
                // Wrap phase
                if self.phase >= 1.0 {
                    self.phase -= self.phase.floor();
                }
            }
        }
        
        // Calculate current step from phase
        // phase 0.0 = step 0, phase 1.0 = back to step 0
        self.current_step = ((self.phase * self.length as f64) as usize) % self.length;
        
        // Generate events on step transitions
        let events = self.check_step_transition();
        
        // Return playhead position (0.0 to 1.0)
        (events, self.phase as f32)
    }
    
    /// Check for step transition and generate note events
    fn check_step_transition(&mut self) -> Vec<SequencerEvent> {
        let mut events = Vec::new();
        
        if self.current_step as isize == self.prev_step {
            return events;
        }
        
        // Bounds check
        if self.steps.is_empty() {
            self.prev_step = self.current_step as isize;
            return events;
        }
        
        let curr_step_idx = self.current_step.min(self.steps.len() - 1);
        let prev_step_idx = if self.prev_step >= 0 {
            (self.prev_step as usize).min(self.steps.len() - 1)
        } else {
            (self.current_step + self.length - 1) % self.length
        };
        
        let curr_step = &self.steps[curr_step_idx];
        let prev_step = &self.steps[prev_step_idx.min(self.steps.len() - 1)];
        
        // Collect notes to release (can't modify held_notes while iterating)
        let notes_to_release: Vec<u8> = self.held_notes.iter()
            .filter(|&&held_note| {
                // Check if this note should be released
                let continues_with_legato = curr_step.notes.iter().any(|new_note| {
                    new_note.midi == held_note && new_note.legato &&
                    prev_step.notes.iter().any(|prev_note| prev_note.midi == held_note)
                });
                !continues_with_legato
            })
            .copied()
            .collect();
        
        // Release notes
        for note in &notes_to_release {
            events.push(SequencerEvent::NoteOff { note: *note });
            self.held_notes.remove(note);
        }
        
        // Trigger new notes
        for note in &curr_step.notes {
            // Check if this is a legato continuation
            let is_legato_continuation = note.legato &&
                prev_step.notes.iter().any(|prev_note| prev_note.midi == note.midi) &&
                self.held_notes.contains(&note.midi);
            
            if !is_legato_continuation {
                events.push(SequencerEvent::NoteOn {
                    note: note.midi,
                    vel: note.vel,
                });
                self.held_notes.insert(note.midi);
            }
        }
        
        self.prev_step = self.current_step as isize;
        events
    }
    
    /// Get current playhead position for UI updates
    pub fn playhead(&self) -> (usize, f32) {
        (self.current_step, self.phase as f32)
    }
    
    /// Check if currently playing
    pub fn is_playing(&self) -> bool {
        self.playing
    }
    
    /// Get step duration in samples (for testing)
    #[cfg(test)]
    pub fn step_duration_samples(&self) -> usize {
        // phase_inc is per-sample increment for full loop
        // step_duration = 1.0 / (phase_inc * length)
        if self.phase_inc > 0.0 {
            (1.0 / (self.phase_inc * self.length as f64)) as usize
        } else {
            0
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_step_duration_calculation() {
        let mut seq = SequencerModule::new(44100.0);
        seq.set_mode(SequencerMode::Poly);
        seq.set_local_bpm(120.0);
        // Set pattern with 16 steps at 1/16 resolution
        seq.set_pattern(vec![SequencerStep { notes: vec![] }; 16], SequencerResolution::Sixteenth, 16);
        
        // 120 BPM = 2 beats per second
        // 1/16 resolution = 4 steps per beat
        // So 8 steps per second
        // Each step = 1/8 second = 5512.5 samples at 44.1kHz
        let expected_samples = 5512;
        let actual = seq.step_duration_samples();
        assert!((actual as i32 - expected_samples).abs() < 2, 
            "Expected ~{} samples per step, got {}", expected_samples, actual);
    }
    
    #[test]
    fn test_step_transition_poly_mode() {
        let mut seq = SequencerModule::new(44100.0);
        
        // Set up a simple 2-step pattern
        seq.set_pattern(
            vec![
                SequencerStep { notes: vec![SequencerNote { midi: 60, vel: 0.8, legato: false }] },
                SequencerStep { notes: vec![] },
            ],
            SequencerResolution::Quarter,
            2
        );
        
        seq.set_mode(SequencerMode::Poly);
        seq.set_local_bpm(60.0); // 1 beat per second
        seq.start();
        
        // Process first sample - should trigger note on
        let (events, _) = seq.process(0.0);
        assert_eq!(events.len(), 1, "First sample should trigger note on");
        assert!(matches!(&events[0], SequencerEvent::NoteOn { note: 60, .. }));
        
        // Run until we see a note off (step transition)
        let mut note_off_sample = 0;
        let max_samples = 50000; // Safety limit
        
        for i in 1..max_samples {
            let (events, _) = seq.process(0.0);
            if !events.is_empty() {
                assert_eq!(events.len(), 1, "Expected single event at step boundary");
                assert!(matches!(&events[0], SequencerEvent::NoteOff { note: 60 }), 
                    "Expected NoteOff at step boundary, got {:?}", events[0]);
                note_off_sample = i;
                break;
            }
        }
        
        // Note off should happen around 44100 samples (1 beat at 60 BPM)
        // Allow some tolerance for floating point
        let expected = 44100;
        assert!((note_off_sample as i32 - expected).abs() < 10, 
            "Note off at sample {}, expected ~{}", note_off_sample, expected);
    }
    
    #[test]
    fn test_phase_accumulation_precision() {
        // Test that phase accumulation doesn't drift significantly over time
        let mut seq = SequencerModule::new(44100.0);
        seq.set_pattern(vec![SequencerStep { notes: vec![] }; 16], SequencerResolution::Sixteenth, 16);
        seq.set_mode(SequencerMode::Poly);
        seq.set_local_bpm(120.0);
        seq.start();
        
        // Run for 1 minute worth of samples
        let samples_per_minute = 44100 * 60;
        for _ in 0..samples_per_minute {
            seq.process(0.0);
        }
        
        // At 120 BPM, 1/16 resolution, 16 steps:
        // - 8 steps per second
        // - 480 loops per minute
        // Phase should be very close to 0.0 (within floating point tolerance)
        
        // 120 BPM = 2 beats/sec = 8 steps/sec
        // 60 seconds = 480 steps = 30 complete loops
        let expected_loops: f64 = (120.0 / 60.0) * 4.0 * 60.0 / 16.0; // 30 loops
        assert!((expected_loops - 30.0).abs() < 0.01, "Math check failed");
        
        // We should be at or very near step 0
        assert!(seq.current_step < 2 || seq.current_step > 14, 
            "After 30 complete loops, expected step near 0, got {}", seq.current_step);
    }
    
    #[test]
    fn test_legato_continuation() {
        let mut seq = SequencerModule::new(44100.0);
        
        // Pattern where note continues with legato
        seq.set_pattern(
            vec![
                SequencerStep { notes: vec![SequencerNote { midi: 60, vel: 0.8, legato: false }] },
                SequencerStep { notes: vec![SequencerNote { midi: 60, vel: 0.8, legato: true }] },
                SequencerStep { notes: vec![] },
            ],
            SequencerResolution::Quarter,
            3
        );
        
        seq.set_mode(SequencerMode::Poly);
        seq.set_local_bpm(60.0);
        seq.start();
        
        // First step - note on
        let (events, _) = seq.process(0.0);
        assert_eq!(events.len(), 1);
        assert!(matches!(&events[0], SequencerEvent::NoteOn { note: 60, .. }));
        
        // Track state through the pattern
        let max_samples = 150000; // 3+ beats at 60 BPM
        let mut step_events: Vec<(usize, Vec<SequencerEvent>)> = vec![(0, events)];
        let mut last_step = seq.current_step;
        
        for i in 1..max_samples {
            let (events, _) = seq.process(0.0);
            
            // Record events at step boundaries
            if seq.current_step != last_step {
                step_events.push((i, events));
                last_step = seq.current_step;
                
                // Stop after we've seen step 2 (the empty step after legato)
                if step_events.len() >= 3 {
                    break;
                }
            }
        }
        
        // We should have:
        // step_events[0] = step 0 entry: NoteOn
        // step_events[1] = step 1 entry (legato): no events (note continues)
        // step_events[2] = step 2 entry (empty): NoteOff
        
        assert!(step_events.len() >= 3, "Should have recorded 3 step transitions");
        
        // Step 0: NoteOn
        assert_eq!(step_events[0].1.len(), 1);
        assert!(matches!(&step_events[0].1[0], SequencerEvent::NoteOn { note: 60, .. }));
        
        // Step 1: Legato - no events (note continues)
        assert_eq!(step_events[1].1.len(), 0, 
            "Legato step should not generate events, got {:?}", step_events[1].1);
        
        // Step 2: Empty - NoteOff
        assert_eq!(step_events[2].1.len(), 1);
        assert!(matches!(&step_events[2].1[0], SequencerEvent::NoteOff { note: 60 }));
    }
    
    #[test]
    fn test_tempo_mode_sync() {
        // Test that tempo mode responds correctly to transport phase changes
        let mut seq = SequencerModule::new(44100.0);
        
        seq.set_pattern(
            vec![
                SequencerStep { notes: vec![SequencerNote { midi: 60, vel: 0.8, legato: false }] },
                SequencerStep { notes: vec![SequencerNote { midi: 62, vel: 0.8, legato: false }] },
                SequencerStep { notes: vec![SequencerNote { midi: 64, vel: 0.8, legato: false }] },
                SequencerStep { notes: vec![SequencerNote { midi: 65, vel: 0.8, legato: false }] },
            ],
            SequencerResolution::Quarter, // 1 step per beat
            4
        );
        
        seq.set_mode(SequencerMode::Tempo);
        seq.set_bpm(120.0); // 2 beats per second
        seq.start();
        
        // Simulate transport phase progressing
        // At 120 BPM, 44100 SR: phase_inc = 120/60 / 44100 = 0.0000453...
        let phase_inc: f32 = 120.0 / 60.0 / 44100.0;
        let mut transport_phase: f32 = 0.0;
        
        // Run through multiple beats and verify step changes happen at beat boundaries
        let mut beat_count = 0;
        let mut last_transport_phase = 0.0_f32;
        
        for _ in 0..200000 {
            let (events, _) = seq.process(transport_phase);
            
            // Detect beat boundary
            if transport_phase < last_transport_phase - 0.5 {
                beat_count += 1;
            }
            last_transport_phase = transport_phase;
            
            // Advance transport
            transport_phase += phase_inc;
            if transport_phase >= 1.0 {
                transport_phase -= 1.0;
            }
            
            // After 4 beats we should have looped
            if beat_count >= 4 {
                break;
            }
            
            // Just verify we don't panic and events are reasonable
            for event in &events {
                match event {
                    SequencerEvent::NoteOn { note, .. } => {
                        assert!(*note >= 60 && *note <= 65, "Unexpected note: {}", note);
                    }
                    SequencerEvent::NoteOff { note } => {
                        assert!(*note >= 60 && *note <= 65, "Unexpected note: {}", note);
                    }
                }
            }
        }
        
        assert!(beat_count >= 4, "Should have completed 4 beats");
    }
    
    #[test]
    fn test_step_duration_consistency() {
        // Verify that all steps have equal duration (no swing)
        let mut seq = SequencerModule::new(44100.0);
        
        // 16-step pattern
        let steps: Vec<SequencerStep> = (0..16)
            .map(|i| SequencerStep { 
                notes: vec![SequencerNote { midi: 60 + (i as u8), vel: 0.8, legato: false }] 
            })
            .collect();
        
        seq.set_pattern(steps, SequencerResolution::Sixteenth, 16);
        seq.set_mode(SequencerMode::Poly);
        seq.set_local_bpm(120.0);
        seq.start();
        
        let mut step_starts: Vec<usize> = vec![0];
        let mut last_step = 0;
        
        // Run for 2+ loops
        let max_samples = 500000;
        
        for i in 1..max_samples {
            seq.process(0.0);
            if seq.current_step != last_step {
                step_starts.push(i);
                last_step = seq.current_step;
                
                // Stop after collecting enough data (32+ transitions)
                if step_starts.len() > 34 {
                    break;
                }
            }
        }
        
        // Calculate durations
        let durations: Vec<usize> = step_starts.windows(2)
            .map(|w| w[1] - w[0])
            .collect();
        
        // Expected: 44100 / 8 = 5512.5 samples per step
        let expected = 5512.5_f64;
        
        // Check that all durations are within 1 sample of expected
        let min = *durations.iter().min().unwrap() as f64;
        let max = *durations.iter().max().unwrap() as f64;
        
        // Allow +/- 1 sample tolerance (unavoidable with discrete samples)
        assert!(max - min <= 1.0, 
            "Step durations should be consistent! Min: {}, Max: {}, Expected: {:.1}\nDurations: {:?}", 
            min, max, expected, &durations[0..16.min(durations.len())]);
        
        // Check average is close to expected
        let avg: f64 = durations.iter().sum::<usize>() as f64 / durations.len() as f64;
        assert!((avg - expected).abs() < 1.0,
            "Average step duration {} should be close to expected {}", avg, expected);
    }
    
    #[test]
    fn test_step_duration_consistency_tempo_mode() {
        // Verify that Tempo mode also has consistent step durations
        let mut seq = SequencerModule::new(44100.0);
        
        // 16-step pattern
        let steps: Vec<SequencerStep> = (0..16)
            .map(|i| SequencerStep { 
                notes: vec![SequencerNote { midi: 60 + (i as u8), vel: 0.8, legato: false }] 
            })
            .collect();
        
        seq.set_pattern(steps, SequencerResolution::Sixteenth, 16);
        seq.set_mode(SequencerMode::Tempo);
        seq.set_bpm(120.0);
        seq.start();
        
        // Simulate transport like the real audio engine does
        let phase_inc: f64 = 120.0 / 60.0 / 44100.0;
        let mut transport_phase: f64 = 0.0;
        
        let mut step_starts: Vec<usize> = vec![0];
        let mut last_step = 0;
        
        // Run for 2+ loops
        let max_samples = 500000;
        
        for i in 1..max_samples {
            seq.process(transport_phase as f32);
            
            transport_phase += phase_inc;
            if transport_phase >= 1.0 {
                transport_phase -= 1.0;
            }
            
            if seq.current_step != last_step {
                step_starts.push(i);
                last_step = seq.current_step;
                
                if step_starts.len() > 34 {
                    break;
                }
            }
        }
        
        // Calculate durations
        let durations: Vec<usize> = step_starts.windows(2)
            .map(|w| w[1] - w[0])
            .collect();
        
        // Expected: 44100 / 8 = 5512.5 samples per step
        let expected = 5512.5_f64;
        
        let min = *durations.iter().min().unwrap() as f64;
        let max = *durations.iter().max().unwrap() as f64;
        
        println!("Tempo mode step durations: {:?}", &durations[0..16.min(durations.len())]);
        println!("Min: {}, Max: {}, Spread: {}", min, max, max - min);
        
        // In tempo mode we might have slightly more variance due to beat snapping
        // But it should still be within a few samples
        assert!(max - min <= 3.0, 
            "Step durations vary too much! Min: {}, Max: {}, Expected: {:.1}\nDurations: {:?}", 
            min, max, expected, &durations[0..16.min(durations.len())]);
    }
}
